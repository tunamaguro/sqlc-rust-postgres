//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
pub const GET_BOOK_WITH_AUTHOR_AND_CATEGORIES: &str = r#"-- name: GetBookWithAuthorAndCategories :many
SELECT 
    b.id,
    b.title,
    b.published_year,
    a.id,
    a.name,
    a.birth_year,
    c.id,
    c.name,
    c.description
FROM books b
JOIN authors a ON b.author_id = a.id
JOIN book_categories bc ON b.id = bc.book_id
JOIN categories c ON bc.category_id = c.id
WHERE b.published_year > $1"#;
#[derive(Debug, Clone)]
pub struct GetBookWithAuthorAndCategoriesRow {
    pub books_id: i32,
    pub books_title: String,
    pub books_published_year: Option<i32>,
    pub authors_id: i32,
    pub authors_name: String,
    pub authors_birth_year: Option<i32>,
    pub categories_id: i32,
    pub categories_name: String,
    pub categories_description: Option<String>,
}
pub async fn get_book_with_author_and_categories(
    client: &impl tokio_postgres::GenericClient,
    books_published_year: Option<&i32>,
) -> Result<
    impl Iterator<Item = Result<GetBookWithAuthorAndCategoriesRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client
        .query(
            GET_BOOK_WITH_AUTHOR_AND_CATEGORIES,
            &[&books_published_year],
        )
        .await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetBookWithAuthorAndCategoriesRow {
            books_id: r.try_get(0)?,
            books_title: r.try_get(1)?,
            books_published_year: r.try_get(2)?,
            authors_id: r.try_get(3)?,
            authors_name: r.try_get(4)?,
            authors_birth_year: r.try_get(5)?,
            categories_id: r.try_get(6)?,
            categories_name: r.try_get(7)?,
            categories_description: r.try_get(8)?,
        })
    }))
}
pub const GET_EMPLOYEES_WITH_MANAGERS: &str = r#"-- name: GetEmployeesWithManagers :many
SELECT 
    e.id,
    e.name,
    e.department,
    e.salary,
    m.id,
    m.name,
    m.department
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id"#;
#[derive(Debug, Clone)]
pub struct GetEmployeesWithManagersRow {
    pub employees_id_1: i32,
    pub employees_name_1: String,
    pub employees_department_1: Option<String>,
    pub employees_salary: Option<i32>,
    pub employees_id_2: Option<i32>,
    pub employees_name_2: Option<String>,
    pub employees_department_2: Option<String>,
}
pub async fn get_employees_with_managers(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetEmployeesWithManagersRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_EMPLOYEES_WITH_MANAGERS, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetEmployeesWithManagersRow {
            employees_id_1: r.try_get(0)?,
            employees_name_1: r.try_get(1)?,
            employees_department_1: r.try_get(2)?,
            employees_salary: r.try_get(3)?,
            employees_id_2: r.try_get(4)?,
            employees_name_2: r.try_get(5)?,
            employees_department_2: r.try_get(6)?,
        })
    }))
}
pub const GET_TOP_RATED_BOOKS: &str = r#"-- name: GetTopRatedBooks :many
SELECT id, title, published_year
FROM books
WHERE id IN (
    SELECT book_id 
    FROM reviews 
    WHERE rating >= $1
)"#;
#[derive(Debug, Clone)]
pub struct GetTopRatedBooksRow {
    pub id: i32,
    pub title: String,
    pub published_year: Option<i32>,
}
pub async fn get_top_rated_books(
    client: &impl tokio_postgres::GenericClient,
    rating: Option<&i32>,
) -> Result<
    impl Iterator<Item = Result<GetTopRatedBooksRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_TOP_RATED_BOOKS, &[&rating]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetTopRatedBooksRow {
            id: r.try_get(0)?,
            title: r.try_get(1)?,
            published_year: r.try_get(2)?,
        })
    }))
}
pub const GET_AUTHOR_BOOK_STATS: &str = r#"-- name: GetAuthorBookStats :many
SELECT 
    a.id,
    a.name,
    COUNT(DISTINCT b.id) as book_count,
    AVG(r.rating) as avg_rating,
    b.id,
    b.title
FROM authors a
LEFT JOIN books b ON a.id = b.author_id
LEFT JOIN reviews r ON b.id = r.book_id
WHERE b.id IS NOT NULL
GROUP BY a.id, a.name, b.id, b.title
HAVING COUNT(DISTINCT b.id) > $1"#;
#[derive(Debug, Clone)]
pub struct GetAuthorBookStatsRow {
    pub authors_id: i32,
    pub authors_name: String,
    pub book_count: i64,
    pub avg_rating: f64,
    pub books_id: Option<i32>,
    pub books_title: Option<String>,
}
pub async fn get_author_book_stats(
    client: &impl tokio_postgres::GenericClient,
    books_id: &i32,
) -> Result<
    impl Iterator<Item = Result<GetAuthorBookStatsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_AUTHOR_BOOK_STATS, &[&books_id]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetAuthorBookStatsRow {
            authors_id: r.try_get(0)?,
            authors_name: r.try_get(1)?,
            book_count: r.try_get(2)?,
            avg_rating: r.try_get(3)?,
            books_id: r.try_get(4)?,
            books_title: r.try_get(5)?,
        })
    }))
}
pub const COMPARE_BOOK_YEARS: &str = r#"-- name: CompareBookYears :many
SELECT 
    old_books.id,
    old_books.title,
    old_books.published_year,
    new_books.id,
    new_books.title,
    new_books.published_year
FROM books old_books
CROSS JOIN books new_books
WHERE old_books.published_year < $1 
  AND new_books.published_year > $2
  AND old_books.id != new_books.id
LIMIT 10"#;
#[derive(Debug, Clone)]
pub struct CompareBookYearsRow {
    pub books_id_1: i32,
    pub books_title_1: String,
    pub books_published_year_1: Option<i32>,
    pub books_id_2: i32,
    pub books_title_2: String,
    pub books_published_year_2: Option<i32>,
}
pub async fn compare_book_years(
    client: &impl tokio_postgres::GenericClient,
    books_published_year_1: Option<&i32>,
    books_published_year_2: Option<&i32>,
) -> Result<
    impl Iterator<Item = Result<CompareBookYearsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client
        .query(
            COMPARE_BOOK_YEARS,
            &[&books_published_year_1, &books_published_year_2],
        )
        .await?;
    Ok(rows.into_iter().map(|r| {
        Ok(CompareBookYearsRow {
            books_id_1: r.try_get(0)?,
            books_title_1: r.try_get(1)?,
            books_published_year_1: r.try_get(2)?,
            books_id_2: r.try_get(3)?,
            books_title_2: r.try_get(4)?,
            books_published_year_2: r.try_get(5)?,
        })
    }))
}
pub const GET_BOOKS_WITH_ALIASES: &str = r#"-- name: GetBooksWithAliases :many
SELECT 
    id as book_id,
    title as book_title,
    published_year as year
FROM books
WHERE published_year BETWEEN $1 AND $2"#;
#[derive(Debug, Clone)]
pub struct GetBooksWithAliasesRow {
    pub book_id: i32,
    pub book_title: String,
    pub year: Option<i32>,
}
pub async fn get_books_with_aliases(
    client: &impl tokio_postgres::GenericClient,
    published_year_start: Option<&i32>,
    published_year_end: Option<&i32>,
) -> Result<
    impl Iterator<Item = Result<GetBooksWithAliasesRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client
        .query(
            GET_BOOKS_WITH_ALIASES,
            &[&published_year_start, &published_year_end],
        )
        .await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetBooksWithAliasesRow {
            book_id: r.try_get(0)?,
            book_title: r.try_get(1)?,
            year: r.try_get(2)?,
        })
    }))
}
pub const GET_CATEGORY_STATS: &str = r#"-- name: GetCategoryStats :many
SELECT 
    c.id,
    c.name,
    COUNT(DISTINCT b.id) as book_count,
    COUNT(DISTINCT a.id) as author_count,
    AVG(r.rating) as avg_rating
FROM categories c
LEFT JOIN book_categories bc ON c.id = bc.category_id
LEFT JOIN books b ON bc.book_id = b.id
LEFT JOIN authors a ON b.author_id = a.id
LEFT JOIN reviews r ON b.id = r.book_id
GROUP BY c.id, c.name
HAVING COUNT(DISTINCT b.id) > 0"#;
#[derive(Debug, Clone)]
pub struct GetCategoryStatsRow {
    pub id: i32,
    pub name: String,
    pub book_count: i64,
    pub author_count: i64,
    pub avg_rating: f64,
}
pub async fn get_category_stats(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetCategoryStatsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_CATEGORY_STATS, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetCategoryStatsRow {
            id: r.try_get(0)?,
            name: r.try_get(1)?,
            book_count: r.try_get(2)?,
            author_count: r.try_get(3)?,
            avg_rating: r.try_get(4)?,
        })
    }))
}
