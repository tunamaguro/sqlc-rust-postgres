//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
#[derive(Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "status")]
pub enum Status {
    #[postgres(name = "op!en")]
    Open,
    #[postgres(name = "clo@sed")]
    Closed,
}
pub const LIST_CITIES: &str = r#"-- name: ListCities :many
SELECT slug, name
FROM city
ORDER BY name"#;
#[derive(Debug, Clone)]
pub struct ListCitiesRow {
    pub slug: String,
    pub name: String,
}
pub async fn list_cities(
    client: &impl deadpool_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<ListCitiesRow, deadpool_postgres::tokio_postgres::Error>>,
    deadpool_postgres::tokio_postgres::Error,
> {
    let rows = client.query(LIST_CITIES, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(ListCitiesRow {
            slug: r.try_get(0)?,
            name: r.try_get(1)?,
        })
    }))
}
pub const GET_CITY: &str = r#"-- name: GetCity :one
SELECT slug, name
FROM city
WHERE slug = $1"#;
#[derive(Debug, Clone)]
pub struct GetCityRow {
    pub slug: String,
    pub name: String,
}
pub async fn get_city(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
) -> Result<Option<GetCityRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client.query_opt(GET_CITY, &[&slug]).await?;
    let v = match row {
        Some(v) => GetCityRow {
            slug: v.try_get(0)?,
            name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const CREATE_CITY: &str = r#"-- name: CreateCity :one
INSERT INTO city (
    name,
    slug
) VALUES (
    $1,
    $2
) RETURNING slug, name"#;
#[derive(Debug, Clone)]
pub struct CreateCityRow {
    pub slug: String,
    pub name: String,
}
pub async fn create_city(
    client: &impl deadpool_postgres::GenericClient,
    name: &str,
    slug: &str,
) -> Result<Option<CreateCityRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client.query_opt(CREATE_CITY, &[&name, &slug]).await?;
    let v = match row {
        Some(v) => CreateCityRow {
            slug: v.try_get(0)?,
            name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const UPDATE_CITY_NAME: &str = r#"-- name: UpdateCityName :exec
UPDATE city
SET name = $2
WHERE slug = $1"#;
pub async fn update_city_name(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
    name: &str,
) -> Result<u64, deadpool_postgres::tokio_postgres::Error> {
    client.execute(UPDATE_CITY_NAME, &[&slug, &name]).await
}
pub const LIST_VENUES: &str = r#"-- name: ListVenues :many
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE city = $1
ORDER BY name"#;
#[derive(Debug, Clone)]
pub struct ListVenuesRow {
    pub id: i32,
    pub status: Status,
    pub statuses: Option<Vec<Status>>,
    pub slug: String,
    pub name: String,
    pub city: String,
    pub spotify_playlist: String,
    pub songkick_id: Option<String>,
    pub tags: Option<Vec<String>>,
    pub created_at: ::std::time::SystemTime,
}
pub async fn list_venues(
    client: &impl deadpool_postgres::GenericClient,
    city: &str,
) -> Result<
    impl Iterator<Item = Result<ListVenuesRow, deadpool_postgres::tokio_postgres::Error>>,
    deadpool_postgres::tokio_postgres::Error,
> {
    let rows = client.query(LIST_VENUES, &[&city]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(ListVenuesRow {
            id: r.try_get(0)?,
            status: r.try_get(1)?,
            statuses: r.try_get(2)?,
            slug: r.try_get(3)?,
            name: r.try_get(4)?,
            city: r.try_get(5)?,
            spotify_playlist: r.try_get(6)?,
            songkick_id: r.try_get(7)?,
            tags: r.try_get(8)?,
            created_at: r.try_get(9)?,
        })
    }))
}
pub const DELETE_VENUE: &str = r#"-- name: DeleteVenue :exec
DELETE FROM venue
WHERE slug = $1 AND slug = $1"#;
pub async fn delete_venue(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
) -> Result<u64, deadpool_postgres::tokio_postgres::Error> {
    client.execute(DELETE_VENUE, &[&slug]).await
}
pub const GET_VENUE: &str = r#"-- name: GetVenue :one
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE slug = $1 AND city = $2"#;
#[derive(Debug, Clone)]
pub struct GetVenueRow {
    pub id: i32,
    pub status: Status,
    pub statuses: Option<Vec<Status>>,
    pub slug: String,
    pub name: String,
    pub city: String,
    pub spotify_playlist: String,
    pub songkick_id: Option<String>,
    pub tags: Option<Vec<String>>,
    pub created_at: ::std::time::SystemTime,
}
pub async fn get_venue(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
    city: &str,
) -> Result<Option<GetVenueRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client.query_opt(GET_VENUE, &[&slug, &city]).await?;
    let v = match row {
        Some(v) => GetVenueRow {
            id: v.try_get(0)?,
            status: v.try_get(1)?,
            statuses: v.try_get(2)?,
            slug: v.try_get(3)?,
            name: v.try_get(4)?,
            city: v.try_get(5)?,
            spotify_playlist: v.try_get(6)?,
            songkick_id: v.try_get(7)?,
            tags: v.try_get(8)?,
            created_at: v.try_get(9)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const CREATE_VENUE: &str = r#"-- name: CreateVenue :one
INSERT INTO venue (
    slug,
    name,
    city,
    created_at,
    spotify_playlist,
    status,
    statuses,
    tags
) VALUES (
    $1,
    $2,
    $3,
    NOW(),
    $4,
    $5,
    $6,
    $7
) RETURNING id"#;
#[derive(Debug, Clone)]
pub struct CreateVenueRow {
    pub id: i32,
}
pub async fn create_venue(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
    name: &str,
    city: &str,
    spotify_playlist: &str,
    status: Status,
    statuses: Option<&[Status]>,
    tags: Option<&[String]>,
) -> Result<Option<CreateVenueRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client
        .query_opt(
            CREATE_VENUE,
            &[
                &slug,
                &name,
                &city,
                &spotify_playlist,
                &status,
                &statuses,
                &tags,
            ],
        )
        .await?;
    let v = match row {
        Some(v) => CreateVenueRow { id: v.try_get(0)? },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const UPDATE_VENUE_NAME: &str = r#"-- name: UpdateVenueName :one
UPDATE venue
SET name = $2
WHERE slug = $1
RETURNING id"#;
#[derive(Debug, Clone)]
pub struct UpdateVenueNameRow {
    pub id: i32,
}
pub async fn update_venue_name(
    client: &impl deadpool_postgres::GenericClient,
    slug: &str,
    name: &str,
) -> Result<Option<UpdateVenueNameRow>, deadpool_postgres::tokio_postgres::Error> {
    let row = client.query_opt(UPDATE_VENUE_NAME, &[&slug, &name]).await?;
    let v = match row {
        Some(v) => UpdateVenueNameRow { id: v.try_get(0)? },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const VENUE_COUNT_BY_CITY: &str = r#"-- name: VenueCountByCity :many
SELECT
    city,
    count(*)
FROM venue
GROUP BY 1
ORDER BY 1"#;
#[derive(Debug, Clone)]
pub struct VenueCountByCityRow {
    pub city: String,
    pub count: i64,
}
pub async fn venue_count_by_city(
    client: &impl deadpool_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<VenueCountByCityRow, deadpool_postgres::tokio_postgres::Error>>,
    deadpool_postgres::tokio_postgres::Error,
> {
    let rows = client.query(VENUE_COUNT_BY_CITY, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(VenueCountByCityRow {
            city: r.try_get(0)?,
            count: r.try_get(1)?,
        })
    }))
}
