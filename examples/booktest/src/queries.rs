//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
#[derive(Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "book_type")]
pub enum BookType {
    #[postgres(name = "FICTION")]
    Fiction,
    #[postgres(name = "NONFICTION")]
    Nonfiction,
}
pub const GET_AUTHOR: &str = r#"-- name: GetAuthor :one
SELECT author_id, name FROM authors
WHERE author_id = $1"#;
#[derive(Debug, Clone)]
pub struct GetAuthorRow {
    pub author_id: i32,
    pub name: String,
}
impl GetAuthorRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetAuthorRow {
            author_id: row.try_get(0)?,
            name: row.try_get(1)?,
        })
    }
}
pub async fn get_author(
    client: &impl tokio_postgres::GenericClient,
    author_id: i32,
) -> Result<Option<GetAuthorRow>, tokio_postgres::Error> {
    let query_struct = GetAuthor {
        author_id: author_id,
    };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct GetAuthor {
    pub author_id: i32,
}
impl GetAuthor {
    pub const QUERY: &'static str = r#"-- name: GetAuthor :one
SELECT author_id, name FROM authors
WHERE author_id = $1"#;
}
impl GetAuthor {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<GetAuthorRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &[&self.author_id]).await?;
        GetAuthorRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<GetAuthorRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &[&self.author_id]).await?;
        match row {
            Some(ref row) => Ok(Some(GetAuthorRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
#[derive(Debug, Default)]
pub struct GetAuthorBuilder {
    author_id: Option<i32>,
}
impl GetAuthor {
    pub fn builder() -> GetAuthorBuilder {
        GetAuthorBuilder::default()
    }
}
impl GetAuthorBuilder {
    pub fn author_id(mut self, author_id: i32) -> Self {
        self.author_id = Some(author_id);
        self
    }
    pub fn build(self) -> GetAuthor {
        GetAuthor {
            author_id: self.author_id.expect("Missing required field"),
        }
    }
}
pub const GET_BOOK: &str = r#"-- name: GetBook :one
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE book_id = $1"#;
#[derive(Debug, Clone)]
pub struct GetBookRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
impl GetBookRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetBookRow {
            book_id: row.try_get(0)?,
            author_id: row.try_get(1)?,
            isbn: row.try_get(2)?,
            book_type: row.try_get(3)?,
            title: row.try_get(4)?,
            year: row.try_get(5)?,
            available: row.try_get(6)?,
            tags: row.try_get(7)?,
        })
    }
}
pub async fn get_book(
    client: &impl tokio_postgres::GenericClient,
    book_id: i32,
) -> Result<Option<GetBookRow>, tokio_postgres::Error> {
    let query_struct = GetBook { book_id: book_id };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct GetBook {
    pub book_id: i32,
}
impl GetBook {
    pub const QUERY: &'static str = r#"-- name: GetBook :one
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE book_id = $1"#;
}
impl GetBook {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<GetBookRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &[&self.book_id]).await?;
        GetBookRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<GetBookRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &[&self.book_id]).await?;
        match row {
            Some(ref row) => Ok(Some(GetBookRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
#[derive(Debug, Default)]
pub struct GetBookBuilder {
    book_id: Option<i32>,
}
impl GetBook {
    pub fn builder() -> GetBookBuilder {
        GetBookBuilder::default()
    }
}
impl GetBookBuilder {
    pub fn book_id(mut self, book_id: i32) -> Self {
        self.book_id = Some(book_id);
        self
    }
    pub fn build(self) -> GetBook {
        GetBook {
            book_id: self.book_id.expect("Missing required field"),
        }
    }
}
pub const DELETE_BOOK: &str = r#"-- name: DeleteBook :exec
DELETE FROM books
WHERE book_id = $1"#;
pub async fn delete_book(
    client: &impl tokio_postgres::GenericClient,
    book_id: i32,
) -> Result<u64, tokio_postgres::Error> {
    client.execute(DELETE_BOOK, &[&book_id]).await
}
#[derive(Debug)]
pub struct DeleteBook {
    pub book_id: i32,
}
impl DeleteBook {
    pub const QUERY: &'static str = r#"-- name: DeleteBook :exec
DELETE FROM books
WHERE book_id = $1"#;
}
impl DeleteBook {
    pub async fn execute(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<u64, tokio_postgres::Error> {
        client.execute(Self::QUERY, &[&self.book_id]).await
    }
}
#[derive(Debug, Default)]
pub struct DeleteBookBuilder {
    book_id: Option<i32>,
}
impl DeleteBook {
    pub fn builder() -> DeleteBookBuilder {
        DeleteBookBuilder::default()
    }
}
impl DeleteBookBuilder {
    pub fn book_id(mut self, book_id: i32) -> Self {
        self.book_id = Some(book_id);
        self
    }
    pub fn build(self) -> DeleteBook {
        DeleteBook {
            book_id: self.book_id.expect("Missing required field"),
        }
    }
}
pub const BOOKS_BY_TITLE_YEAR: &str = r#"-- name: BooksByTitleYear :many
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE title = $1 AND year = $2"#;
#[derive(Debug, Clone)]
pub struct BooksByTitleYearRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
impl BooksByTitleYearRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(BooksByTitleYearRow {
            book_id: row.try_get(0)?,
            author_id: row.try_get(1)?,
            isbn: row.try_get(2)?,
            book_type: row.try_get(3)?,
            title: row.try_get(4)?,
            year: row.try_get(5)?,
            available: row.try_get(6)?,
            tags: row.try_get(7)?,
        })
    }
}
pub async fn books_by_title_year(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    year: i32,
) -> Result<
    impl Iterator<Item = Result<BooksByTitleYearRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(BOOKS_BY_TITLE_YEAR, &[&title, &year]).await?;
    Ok(rows.into_iter().map(|r| BooksByTitleYearRow::from_row(&r)))
}
#[derive(Debug)]
pub struct BooksByTitleYear<'a> {
    pub title: std::borrow::Cow<'a, str>,
    pub year: i32,
}
impl<'a> BooksByTitleYear<'a> {
    pub const QUERY: &'static str = r#"-- name: BooksByTitleYear :many
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE title = $1 AND year = $2"#;
}
impl<'a> BooksByTitleYear<'a> {
    pub async fn query_many(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Vec<BooksByTitleYearRow>, tokio_postgres::Error> {
        let rows = client
            .query(Self::QUERY, &[&self.title.as_ref(), &self.year])
            .await?;
        rows.into_iter()
            .map(|r| BooksByTitleYearRow::from_row(&r))
            .collect()
    }
    pub async fn query_raw(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<
        impl Iterator<Item = Result<BooksByTitleYearRow, tokio_postgres::Error>>,
        tokio_postgres::Error,
    > {
        let rows = client
            .query(Self::QUERY, &[&self.title.as_ref(), &self.year])
            .await?;
        Ok(rows.into_iter().map(|r| BooksByTitleYearRow::from_row(&r)))
    }
}
#[derive(Debug, Default)]
pub struct BooksByTitleYearBuilder<'a> {
    title: Option<std::borrow::Cow<'a, str>>,
    year: Option<i32>,
}
impl<'a> BooksByTitleYear<'a> {
    pub fn builder() -> BooksByTitleYearBuilder<'a> {
        BooksByTitleYearBuilder::default()
    }
}
impl<'a> BooksByTitleYearBuilder<'a> {
    pub fn title<T>(mut self, title: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.title = Some(title.into());
        self
    }
    pub fn year(mut self, year: i32) -> Self {
        self.year = Some(year);
        self
    }
    pub fn build(self) -> BooksByTitleYear<'a> {
        BooksByTitleYear {
            title: self.title.expect("Missing required field"),
            year: self.year.expect("Missing required field"),
        }
    }
}
pub const BOOKS_BY_TAGS: &str = r#"-- name: BooksByTags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && $1::varchar[]"#;
#[derive(Debug, Clone)]
pub struct BooksByTagsRow {
    pub book_id: i32,
    pub title: String,
    pub name: Option<String>,
    pub isbn: String,
    pub tags: Vec<String>,
}
impl BooksByTagsRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(BooksByTagsRow {
            book_id: row.try_get(0)?,
            title: row.try_get(1)?,
            name: row.try_get(2)?,
            isbn: row.try_get(3)?,
            tags: row.try_get(4)?,
        })
    }
}
pub async fn books_by_tags(
    client: &impl tokio_postgres::GenericClient,
    param: &[String],
) -> Result<
    impl Iterator<Item = Result<BooksByTagsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(BOOKS_BY_TAGS, &[&param]).await?;
    Ok(rows.into_iter().map(|r| BooksByTagsRow::from_row(&r)))
}
#[derive(Debug)]
pub struct BooksByTags<'a> {
    pub param: std::borrow::Cow<'a, [String]>,
}
impl<'a> BooksByTags<'a> {
    pub const QUERY: &'static str = r#"-- name: BooksByTags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && $1::varchar[]"#;
}
impl<'a> BooksByTags<'a> {
    pub async fn query_many(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Vec<BooksByTagsRow>, tokio_postgres::Error> {
        let rows = client.query(Self::QUERY, &[&self.param.as_ref()]).await?;
        rows.into_iter()
            .map(|r| BooksByTagsRow::from_row(&r))
            .collect()
    }
    pub async fn query_raw(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<
        impl Iterator<Item = Result<BooksByTagsRow, tokio_postgres::Error>>,
        tokio_postgres::Error,
    > {
        let rows = client.query(Self::QUERY, &[&self.param.as_ref()]).await?;
        Ok(rows.into_iter().map(|r| BooksByTagsRow::from_row(&r)))
    }
}
#[derive(Debug, Default)]
pub struct BooksByTagsBuilder<'a> {
    param: Option<std::borrow::Cow<'a, [String]>>,
}
impl<'a> BooksByTags<'a> {
    pub fn builder() -> BooksByTagsBuilder<'a> {
        BooksByTagsBuilder::default()
    }
}
impl<'a> BooksByTagsBuilder<'a> {
    pub fn param<T>(mut self, param: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, [String]>>,
    {
        self.param = Some(param.into());
        self
    }
    pub fn build(self) -> BooksByTags<'a> {
        BooksByTags {
            param: self.param.expect("Missing required field"),
        }
    }
}
pub const CREATE_AUTHOR: &str = r#"-- name: CreateAuthor :one
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name"#;
#[derive(Debug, Clone)]
pub struct CreateAuthorRow {
    pub author_id: i32,
    pub name: String,
}
impl CreateAuthorRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(CreateAuthorRow {
            author_id: row.try_get(0)?,
            name: row.try_get(1)?,
        })
    }
}
pub async fn create_author(
    client: &impl tokio_postgres::GenericClient,
    name: &str,
) -> Result<Option<CreateAuthorRow>, tokio_postgres::Error> {
    let query_struct = CreateAuthor {
        name: std::borrow::Cow::Borrowed(name),
    };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct CreateAuthor<'a> {
    pub name: std::borrow::Cow<'a, str>,
}
impl<'a> CreateAuthor<'a> {
    pub const QUERY: &'static str = r#"-- name: CreateAuthor :one
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name"#;
}
impl<'a> CreateAuthor<'a> {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<CreateAuthorRow, tokio_postgres::Error> {
        let row = client
            .query_one(Self::QUERY, &[&self.name.as_ref()])
            .await?;
        CreateAuthorRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<CreateAuthorRow>, tokio_postgres::Error> {
        let row = client
            .query_opt(Self::QUERY, &[&self.name.as_ref()])
            .await?;
        match row {
            Some(ref row) => Ok(Some(CreateAuthorRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
#[derive(Debug, Default)]
pub struct CreateAuthorBuilder<'a> {
    name: Option<std::borrow::Cow<'a, str>>,
}
impl<'a> CreateAuthor<'a> {
    pub fn builder() -> CreateAuthorBuilder<'a> {
        CreateAuthorBuilder::default()
    }
}
impl<'a> CreateAuthorBuilder<'a> {
    pub fn name<T>(mut self, name: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.name = Some(name.into());
        self
    }
    pub fn build(self) -> CreateAuthor<'a> {
        CreateAuthor {
            name: self.name.expect("Missing required field"),
        }
    }
}
pub const CREATE_BOOK: &str = r#"-- name: CreateBook :one
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags"#;
#[derive(Debug, Clone)]
pub struct CreateBookRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
impl CreateBookRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(CreateBookRow {
            book_id: row.try_get(0)?,
            author_id: row.try_get(1)?,
            isbn: row.try_get(2)?,
            book_type: row.try_get(3)?,
            title: row.try_get(4)?,
            year: row.try_get(5)?,
            available: row.try_get(6)?,
            tags: row.try_get(7)?,
        })
    }
}
pub async fn create_book(
    client: &impl tokio_postgres::GenericClient,
    author_id: i32,
    isbn: &str,
    book_type: BookType,
    title: &str,
    year: i32,
    available: &::std::time::SystemTime,
    tags: &[String],
) -> Result<Option<CreateBookRow>, tokio_postgres::Error> {
    let query_struct = CreateBook {
        author_id: author_id,
        isbn: std::borrow::Cow::Borrowed(isbn),
        book_type: book_type,
        title: std::borrow::Cow::Borrowed(title),
        year: year,
        available: std::borrow::Cow::Borrowed(available),
        tags: std::borrow::Cow::Borrowed(tags),
    };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct CreateBook<'a> {
    pub author_id: i32,
    pub isbn: std::borrow::Cow<'a, str>,
    pub book_type: BookType,
    pub title: std::borrow::Cow<'a, str>,
    pub year: i32,
    pub available: std::borrow::Cow<'a, ::std::time::SystemTime>,
    pub tags: std::borrow::Cow<'a, [String]>,
}
impl<'a> CreateBook<'a> {
    pub const QUERY: &'static str = r#"-- name: CreateBook :one
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags"#;
}
impl<'a> CreateBook<'a> {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<CreateBookRow, tokio_postgres::Error> {
        let row = client
            .query_one(
                Self::QUERY,
                &[
                    &self.author_id,
                    &self.isbn.as_ref(),
                    &self.book_type,
                    &self.title.as_ref(),
                    &self.year,
                    &self.available.as_ref(),
                    &self.tags.as_ref(),
                ],
            )
            .await?;
        CreateBookRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<CreateBookRow>, tokio_postgres::Error> {
        let row = client
            .query_opt(
                Self::QUERY,
                &[
                    &self.author_id,
                    &self.isbn.as_ref(),
                    &self.book_type,
                    &self.title.as_ref(),
                    &self.year,
                    &self.available.as_ref(),
                    &self.tags.as_ref(),
                ],
            )
            .await?;
        match row {
            Some(ref row) => Ok(Some(CreateBookRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
#[derive(Debug, Default)]
pub struct CreateBookBuilder<'a> {
    author_id: Option<i32>,
    isbn: Option<std::borrow::Cow<'a, str>>,
    book_type: Option<BookType>,
    title: Option<std::borrow::Cow<'a, str>>,
    year: Option<i32>,
    available: Option<std::borrow::Cow<'a, ::std::time::SystemTime>>,
    tags: Option<std::borrow::Cow<'a, [String]>>,
}
impl<'a> CreateBook<'a> {
    pub fn builder() -> CreateBookBuilder<'a> {
        CreateBookBuilder::default()
    }
}
impl<'a> CreateBookBuilder<'a> {
    pub fn author_id(mut self, author_id: i32) -> Self {
        self.author_id = Some(author_id);
        self
    }
    pub fn isbn<T>(mut self, isbn: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.isbn = Some(isbn.into());
        self
    }
    pub fn book_type(mut self, book_type: BookType) -> Self {
        self.book_type = Some(book_type);
        self
    }
    pub fn title<T>(mut self, title: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.title = Some(title.into());
        self
    }
    pub fn year(mut self, year: i32) -> Self {
        self.year = Some(year);
        self
    }
    pub fn available<T>(mut self, available: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, ::std::time::SystemTime>>,
    {
        self.available = Some(available.into());
        self
    }
    pub fn tags<T>(mut self, tags: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, [String]>>,
    {
        self.tags = Some(tags.into());
        self
    }
    pub fn build(self) -> CreateBook<'a> {
        CreateBook {
            author_id: self.author_id.expect("Missing required field"),
            isbn: self.isbn.expect("Missing required field"),
            book_type: self.book_type.expect("Missing required field"),
            title: self.title.expect("Missing required field"),
            year: self.year.expect("Missing required field"),
            available: self.available.expect("Missing required field"),
            tags: self.tags.expect("Missing required field"),
        }
    }
}
pub const UPDATE_BOOK: &str = r#"-- name: UpdateBook :exec
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3"#;
pub async fn update_book(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    tags: &[String],
    book_id: i32,
) -> Result<u64, tokio_postgres::Error> {
    client
        .execute(UPDATE_BOOK, &[&title, &tags, &book_id])
        .await
}
#[derive(Debug)]
pub struct UpdateBook<'a> {
    pub title: std::borrow::Cow<'a, str>,
    pub tags: std::borrow::Cow<'a, [String]>,
    pub book_id: i32,
}
impl<'a> UpdateBook<'a> {
    pub const QUERY: &'static str = r#"-- name: UpdateBook :exec
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3"#;
}
impl<'a> UpdateBook<'a> {
    pub async fn execute(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<u64, tokio_postgres::Error> {
        client
            .execute(
                Self::QUERY,
                &[&self.title.as_ref(), &self.tags.as_ref(), &self.book_id],
            )
            .await
    }
}
#[derive(Debug, Default)]
pub struct UpdateBookBuilder<'a> {
    title: Option<std::borrow::Cow<'a, str>>,
    tags: Option<std::borrow::Cow<'a, [String]>>,
    book_id: Option<i32>,
}
impl<'a> UpdateBook<'a> {
    pub fn builder() -> UpdateBookBuilder<'a> {
        UpdateBookBuilder::default()
    }
}
impl<'a> UpdateBookBuilder<'a> {
    pub fn title<T>(mut self, title: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.title = Some(title.into());
        self
    }
    pub fn tags<T>(mut self, tags: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, [String]>>,
    {
        self.tags = Some(tags.into());
        self
    }
    pub fn book_id(mut self, book_id: i32) -> Self {
        self.book_id = Some(book_id);
        self
    }
    pub fn build(self) -> UpdateBook<'a> {
        UpdateBook {
            title: self.title.expect("Missing required field"),
            tags: self.tags.expect("Missing required field"),
            book_id: self.book_id.expect("Missing required field"),
        }
    }
}
pub const UPDATE_BOOK_ISBN: &str = r#"-- name: UpdateBookISBN :exec
UPDATE books
SET title = $1, tags = $2, isbn = $4
WHERE book_id = $3"#;
pub async fn update_book_isbn(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    tags: &[String],
    book_id: i32,
    isbn: &str,
) -> Result<u64, tokio_postgres::Error> {
    client
        .execute(UPDATE_BOOK_ISBN, &[&title, &tags, &book_id, &isbn])
        .await
}
#[derive(Debug)]
pub struct UpdateBookIsbn<'a> {
    pub title: std::borrow::Cow<'a, str>,
    pub tags: std::borrow::Cow<'a, [String]>,
    pub book_id: i32,
    pub isbn: std::borrow::Cow<'a, str>,
}
impl<'a> UpdateBookIsbn<'a> {
    pub const QUERY: &'static str = r#"-- name: UpdateBookISBN :exec
UPDATE books
SET title = $1, tags = $2, isbn = $4
WHERE book_id = $3"#;
}
impl<'a> UpdateBookIsbn<'a> {
    pub async fn execute(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<u64, tokio_postgres::Error> {
        client
            .execute(
                Self::QUERY,
                &[
                    &self.title.as_ref(),
                    &self.tags.as_ref(),
                    &self.book_id,
                    &self.isbn.as_ref(),
                ],
            )
            .await
    }
}
#[derive(Debug, Default)]
pub struct UpdateBookIsbnBuilder<'a> {
    title: Option<std::borrow::Cow<'a, str>>,
    tags: Option<std::borrow::Cow<'a, [String]>>,
    book_id: Option<i32>,
    isbn: Option<std::borrow::Cow<'a, str>>,
}
impl<'a> UpdateBookIsbn<'a> {
    pub fn builder() -> UpdateBookIsbnBuilder<'a> {
        UpdateBookIsbnBuilder::default()
    }
}
impl<'a> UpdateBookIsbnBuilder<'a> {
    pub fn title<T>(mut self, title: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.title = Some(title.into());
        self
    }
    pub fn tags<T>(mut self, tags: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, [String]>>,
    {
        self.tags = Some(tags.into());
        self
    }
    pub fn book_id(mut self, book_id: i32) -> Self {
        self.book_id = Some(book_id);
        self
    }
    pub fn isbn<T>(mut self, isbn: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.isbn = Some(isbn.into());
        self
    }
    pub fn build(self) -> UpdateBookIsbn<'a> {
        UpdateBookIsbn {
            title: self.title.expect("Missing required field"),
            tags: self.tags.expect("Missing required field"),
            book_id: self.book_id.expect("Missing required field"),
            isbn: self.isbn.expect("Missing required field"),
        }
    }
}
pub const SAY_HELLO: &str = r#"-- name: SayHello :one
select say_hello from say_hello($1)"#;
#[derive(Debug, Clone)]
pub struct SayHelloRow {
    pub say_hello: Option<String>,
}
impl SayHelloRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(SayHelloRow {
            say_hello: row.try_get(0)?,
        })
    }
}
pub async fn say_hello(
    client: &impl tokio_postgres::GenericClient,
    s: &str,
) -> Result<Option<SayHelloRow>, tokio_postgres::Error> {
    let query_struct = SayHello {
        s: std::borrow::Cow::Borrowed(s),
    };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct SayHello<'a> {
    pub s: std::borrow::Cow<'a, str>,
}
impl<'a> SayHello<'a> {
    pub const QUERY: &'static str = r#"-- name: SayHello :one
select say_hello from say_hello($1)"#;
}
impl<'a> SayHello<'a> {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<SayHelloRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &[&self.s.as_ref()]).await?;
        SayHelloRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<SayHelloRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &[&self.s.as_ref()]).await?;
        match row {
            Some(ref row) => Ok(Some(SayHelloRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
#[derive(Debug, Default)]
pub struct SayHelloBuilder<'a> {
    s: Option<std::borrow::Cow<'a, str>>,
}
impl<'a> SayHello<'a> {
    pub fn builder() -> SayHelloBuilder<'a> {
        SayHelloBuilder::default()
    }
}
impl<'a> SayHelloBuilder<'a> {
    pub fn s<T>(mut self, s: T) -> Self
    where
        T: Into<std::borrow::Cow<'a, str>>,
    {
        self.s = Some(s.into());
        self
    }
    pub fn build(self) -> SayHello<'a> {
        SayHello {
            s: self.s.expect("Missing required field"),
        }
    }
}
