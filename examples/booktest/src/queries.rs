//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
#[derive(Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "book_type")]
pub enum BookType {
    #[postgres(name = "FICTION")]
    Fiction,
    #[postgres(name = "NONFICTION")]
    Nonfiction,
}
pub const GET_AUTHOR: &str = r#"-- name: GetAuthor :one
SELECT author_id, name FROM authors
WHERE author_id = $1"#;
#[derive(Debug, Clone)]
pub struct GetAuthorRow {
    pub author_id: i32,
    pub name: String,
}
pub async fn get_author(
    client: &impl tokio_postgres::GenericClient,
    author_id: &i32,
) -> Result<Option<GetAuthorRow>, tokio_postgres::Error> {
    let row = client.query_opt(GET_AUTHOR, &[&author_id]).await?;
    let v = match row {
        Some(v) => GetAuthorRow {
            author_id: v.try_get(0)?,
            name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const GET_BOOK: &str = r#"-- name: GetBook :one
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE book_id = $1"#;
#[derive(Debug, Clone)]
pub struct GetBookRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
pub async fn get_book(
    client: &impl tokio_postgres::GenericClient,
    book_id: &i32,
) -> Result<Option<GetBookRow>, tokio_postgres::Error> {
    let row = client.query_opt(GET_BOOK, &[&book_id]).await?;
    let v = match row {
        Some(v) => GetBookRow {
            book_id: v.try_get(0)?,
            author_id: v.try_get(1)?,
            isbn: v.try_get(2)?,
            book_type: v.try_get(3)?,
            title: v.try_get(4)?,
            year: v.try_get(5)?,
            available: v.try_get(6)?,
            tags: v.try_get(7)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const DELETE_BOOK: &str = r#"-- name: DeleteBook :exec
DELETE FROM books
WHERE book_id = $1"#;
pub async fn delete_book(
    client: &impl tokio_postgres::GenericClient,
    book_id: &i32,
) -> Result<u64, tokio_postgres::Error> {
    client.execute(DELETE_BOOK, &[&book_id]).await
}
pub const BOOKS_BY_TITLE_YEAR: &str = r#"-- name: BooksByTitleYear :many
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE title = $1 AND year = $2"#;
#[derive(Debug, Clone)]
pub struct BooksByTitleYearRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
pub async fn books_by_title_year(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    year: &i32,
) -> Result<
    impl Iterator<Item = Result<BooksByTitleYearRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(BOOKS_BY_TITLE_YEAR, &[&title, &year]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(BooksByTitleYearRow {
            book_id: r.try_get(0)?,
            author_id: r.try_get(1)?,
            isbn: r.try_get(2)?,
            book_type: r.try_get(3)?,
            title: r.try_get(4)?,
            year: r.try_get(5)?,
            available: r.try_get(6)?,
            tags: r.try_get(7)?,
        })
    }))
}
pub const BOOKS_BY_TAGS: &str = r#"-- name: BooksByTags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && $1::varchar[]"#;
#[derive(Debug, Clone)]
pub struct BooksByTagsRow {
    pub books_book_id: i32,
    pub books_title: String,
    pub authors_name: Option<String>,
    pub books_isbn: String,
    pub books_tags: Vec<String>,
}
pub async fn books_by_tags(
    client: &impl tokio_postgres::GenericClient,
    column_0: &[String],
) -> Result<
    impl Iterator<Item = Result<BooksByTagsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(BOOKS_BY_TAGS, &[&column_0]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(BooksByTagsRow {
            books_book_id: r.try_get(0)?,
            books_title: r.try_get(1)?,
            authors_name: r.try_get(2)?,
            books_isbn: r.try_get(3)?,
            books_tags: r.try_get(4)?,
        })
    }))
}
pub const CREATE_AUTHOR: &str = r#"-- name: CreateAuthor :one
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name"#;
#[derive(Debug, Clone)]
pub struct CreateAuthorRow {
    pub author_id: i32,
    pub name: String,
}
pub async fn create_author(
    client: &impl tokio_postgres::GenericClient,
    name: &str,
) -> Result<Option<CreateAuthorRow>, tokio_postgres::Error> {
    let row = client.query_opt(CREATE_AUTHOR, &[&name]).await?;
    let v = match row {
        Some(v) => CreateAuthorRow {
            author_id: v.try_get(0)?,
            name: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const CREATE_BOOK: &str = r#"-- name: CreateBook :one
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags"#;
#[derive(Debug, Clone)]
pub struct CreateBookRow {
    pub book_id: i32,
    pub author_id: i32,
    pub isbn: String,
    pub book_type: BookType,
    pub title: String,
    pub year: i32,
    pub available: ::std::time::SystemTime,
    pub tags: Vec<String>,
}
pub async fn create_book(
    client: &impl tokio_postgres::GenericClient,
    author_id: &i32,
    isbn: &str,
    book_type: &BookType,
    title: &str,
    year: &i32,
    available: &::std::time::SystemTime,
    tags: &[String],
) -> Result<Option<CreateBookRow>, tokio_postgres::Error> {
    let row = client
        .query_opt(
            CREATE_BOOK,
            &[
                &author_id, &isbn, &book_type, &title, &year, &available, &tags,
            ],
        )
        .await?;
    let v = match row {
        Some(v) => CreateBookRow {
            book_id: v.try_get(0)?,
            author_id: v.try_get(1)?,
            isbn: v.try_get(2)?,
            book_type: v.try_get(3)?,
            title: v.try_get(4)?,
            year: v.try_get(5)?,
            available: v.try_get(6)?,
            tags: v.try_get(7)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
pub const UPDATE_BOOK: &str = r#"-- name: UpdateBook :exec
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3"#;
pub async fn update_book(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    tags: &[String],
    book_id: &i32,
) -> Result<u64, tokio_postgres::Error> {
    client
        .execute(UPDATE_BOOK, &[&title, &tags, &book_id])
        .await
}
pub const UPDATE_BOOK_ISBN: &str = r#"-- name: UpdateBookISBN :exec
UPDATE books
SET title = $1, tags = $2, isbn = $4
WHERE book_id = $3"#;
pub async fn update_book_isbn(
    client: &impl tokio_postgres::GenericClient,
    title: &str,
    tags: &[String],
    book_id: &i32,
    isbn: &str,
) -> Result<u64, tokio_postgres::Error> {
    client
        .execute(UPDATE_BOOK_ISBN, &[&title, &tags, &book_id, &isbn])
        .await
}
pub const SAY_HELLO: &str = r#"-- name: SayHello :one
select say_hello from say_hello($1)"#;
#[derive(Debug, Clone)]
pub struct SayHelloRow {
    pub say_hello: Option<String>,
}
pub async fn say_hello(
    client: &impl tokio_postgres::GenericClient,
    s: &str,
) -> Result<Option<SayHelloRow>, tokio_postgres::Error> {
    let row = client.query_opt(SAY_HELLO, &[&s]).await?;
    let v = match row {
        Some(v) => SayHelloRow {
            say_hello: v.try_get(0)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
