//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
#[derive(PartialEq, Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "sponge_bob_character")]
pub enum SpongeBobCharacter {
    #[postgres(name = "Bob")]
    Bob,
    #[postgres(name = "Patrick")]
    Patrick,
    #[postgres(name = "Squidward")]
    Squidward,
}
pub const GET_BOOLS: &str = r#"-- name: GetBools :many
SELECT col_bool, col_bool_alias, col_bool_array1, col_bool_array2
FROM BoolTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetBoolsRow {
    pub col_bool: Option<bool>,
    pub col_bool_alias: Option<bool>,
    pub col_bool_array_1: Option<Vec<bool>>,
    pub col_bool_array_2: Option<Vec<Vec<bool>>>,
}
impl GetBoolsRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetBoolsRow {
            col_bool: row.try_get(0)?,
            col_bool_alias: row.try_get(1)?,
            col_bool_array_1: row.try_get(2)?,
            col_bool_array_2: row.try_get(3)?,
        })
    }
}
pub async fn get_bools(
    client: &impl tokio_postgres::GenericClient,
) -> Result<impl Iterator<Item = Result<GetBoolsRow, tokio_postgres::Error>>, tokio_postgres::Error>
{
    let rows = client.query(GET_BOOLS, &[]).await?;
    Ok(rows.into_iter().map(|r| GetBoolsRow::from_row(&r)))
}
pub const GET_NUMERICS: &str = r#"-- name: GetNumerics :many
SELECT col_smallint, col_smallint_alias, col_integer, col_integer_alias, col_int_alias, col_serial, col_bigint, col_bigint_alias, col_decimal, col_decimal_alias, col_real, col_real_alias, col_double_precision, col_double_precision_alias, col_money
FROM NumericTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetNumericsRow {
    pub col_smallint: Option<i16>,
    pub col_smallint_alias: Option<i16>,
    pub col_integer: Option<i32>,
    pub col_integer_alias: Option<i32>,
    pub col_int_alias: Option<i32>,
    pub col_serial: Option<i32>,
    pub col_bigint: Option<i64>,
    pub col_bigint_alias: Option<i64>,
    pub col_decimal: Option<rust_decimal::Decimal>,
    pub col_decimal_alias: Option<rust_decimal::Decimal>,
    pub col_real: Option<f32>,
    pub col_real_alias: Option<f32>,
    pub col_double_precision: Option<f64>,
    pub col_double_precision_alias: Option<f64>,
    pub col_money: Option<postgres_money::Money>,
}
impl GetNumericsRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetNumericsRow {
            col_smallint: row.try_get(0)?,
            col_smallint_alias: row.try_get(1)?,
            col_integer: row.try_get(2)?,
            col_integer_alias: row.try_get(3)?,
            col_int_alias: row.try_get(4)?,
            col_serial: row.try_get(5)?,
            col_bigint: row.try_get(6)?,
            col_bigint_alias: row.try_get(7)?,
            col_decimal: row.try_get(8)?,
            col_decimal_alias: row.try_get(9)?,
            col_real: row.try_get(10)?,
            col_real_alias: row.try_get(11)?,
            col_double_precision: row.try_get(12)?,
            col_double_precision_alias: row.try_get(13)?,
            col_money: row.try_get(14)?,
        })
    }
}
pub async fn get_numerics(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetNumericsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_NUMERICS, &[]).await?;
    Ok(rows.into_iter().map(|r| GetNumericsRow::from_row(&r)))
}
pub const GET_CHARACTERS: &str = r#"-- name: GetCharacters :many
SELECT col_char, col_char_alias, col_varchar, col_varchar_alias, col_text
FROM CharacterTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetCharactersRow {
    pub col_char: Option<String>,
    pub col_char_alias: Option<String>,
    pub col_varchar: Option<String>,
    pub col_varchar_alias: Option<String>,
    pub col_text: Option<String>,
}
impl GetCharactersRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetCharactersRow {
            col_char: row.try_get(0)?,
            col_char_alias: row.try_get(1)?,
            col_varchar: row.try_get(2)?,
            col_varchar_alias: row.try_get(3)?,
            col_text: row.try_get(4)?,
        })
    }
}
pub async fn get_characters(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetCharactersRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_CHARACTERS, &[]).await?;
    Ok(rows.into_iter().map(|r| GetCharactersRow::from_row(&r)))
}
pub const GET_BINARIES: &str = r#"-- name: GetBinaries :many
SELECT col_bytea
FROM BinaryTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetBinariesRow {
    pub col_bytea: Option<Vec<u8>>,
}
impl GetBinariesRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetBinariesRow {
            col_bytea: row.try_get(0)?,
        })
    }
}
pub async fn get_binaries(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetBinariesRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_BINARIES, &[]).await?;
    Ok(rows.into_iter().map(|r| GetBinariesRow::from_row(&r)))
}
pub const GET_CUSTOM_TYPE: &str = r#"-- name: GetCustomType :many
SELECT voice_actor, character
FROM SpongeBobVoiceActor"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetCustomTypeRow {
    pub voice_actor: Option<crate::VoiceActor>,
    pub character: Option<SpongeBobCharacter>,
}
impl GetCustomTypeRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(GetCustomTypeRow {
            voice_actor: row.try_get(0)?,
            character: row.try_get(1)?,
        })
    }
}
pub async fn get_custom_type(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetCustomTypeRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_CUSTOM_TYPE, &[]).await?;
    Ok(rows.into_iter().map(|r| GetCustomTypeRow::from_row(&r)))
}
pub const CREATE_VOICE_ACTOR: &str = r#"-- name: CreateVoiceActor :one
INSERT INTO SpongeBobVoiceActor
(voice_actor,character)
VALUES ($1, $2)
RETURNING voice_actor, character"#;
#[derive(PartialEq, Debug, Clone)]
pub struct CreateVoiceActorRow {
    pub voice_actor: Option<crate::VoiceActor>,
    pub character: Option<SpongeBobCharacter>,
}
impl CreateVoiceActorRow {
    pub(crate) fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(CreateVoiceActorRow {
            voice_actor: row.try_get(0)?,
            character: row.try_get(1)?,
        })
    }
}
pub async fn create_voice_actor(
    client: &impl tokio_postgres::GenericClient,
    voice_actor: Option<&crate::VoiceActor>,
    character: Option<SpongeBobCharacter>,
) -> Result<Option<CreateVoiceActorRow>, tokio_postgres::Error> {
    let query_struct = CreateVoiceActor {
        voice_actor: voice_actor.map(std::borrow::Cow::Borrowed),
        character: character,
    };
    query_struct.query_opt(client).await
}
#[derive(Debug)]
pub struct CreateVoiceActor<'a> {
    pub voice_actor: Option<std::borrow::Cow<'a, crate::VoiceActor>>,
    pub character: Option<SpongeBobCharacter>,
}
impl<'a> CreateVoiceActor<'a> {
    pub const QUERY: &'static str = r#"-- name: CreateVoiceActor :one
INSERT INTO SpongeBobVoiceActor
(voice_actor,character)
VALUES ($1, $2)
RETURNING voice_actor, character"#;
}
impl<'a> CreateVoiceActor<'a> {
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<CreateVoiceActorRow, tokio_postgres::Error> {
        let row = client
            .query_one(
                Self::QUERY,
                &[&self.voice_actor.as_deref(), &self.character],
            )
            .await?;
        CreateVoiceActorRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<CreateVoiceActorRow>, tokio_postgres::Error> {
        let row = client
            .query_opt(
                Self::QUERY,
                &[&self.voice_actor.as_deref(), &self.character],
            )
            .await?;
        match row {
            Some(ref row) => Ok(Some(CreateVoiceActorRow::from_row(row)?)),
            None => Ok(None),
        }
    }
}
