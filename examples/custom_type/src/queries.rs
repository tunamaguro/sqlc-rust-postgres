//! Code generated by sqlc. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-rust-postgres version: v0.1.4
#[derive(PartialEq, Debug, Clone, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "sponge_bob_character")]
pub enum SpongeBobCharacter {
    #[postgres(name = "Bob")]
    Bob,
    #[postgres(name = "Patrick")]
    Patrick,
    #[postgres(name = "Squidward")]
    Squidward,
}
pub const GET_BOOLS: &str = r#"-- name: GetBools :many
SELECT col_bool, col_bool_alias, col_bool_array1, col_bool_array2
FROM BoolTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetBoolsRow {
    pub col_bool: Option<bool>,
    pub col_bool_alias: Option<bool>,
    pub col_bool_array_1: Option<Vec<bool>>,
    pub col_bool_array_2: Option<Vec<Vec<bool>>>,
}
pub async fn get_bools(
    client: &impl tokio_postgres::GenericClient,
) -> Result<impl Iterator<Item = Result<GetBoolsRow, tokio_postgres::Error>>, tokio_postgres::Error>
{
    let rows = client.query(GET_BOOLS, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetBoolsRow {
            col_bool: r.try_get(0)?,
            col_bool_alias: r.try_get(1)?,
            col_bool_array_1: r.try_get(2)?,
            col_bool_array_2: r.try_get(3)?,
        })
    }))
}
pub const GET_NUMERICS: &str = r#"-- name: GetNumerics :many
SELECT col_smallint, col_smallint_alias, col_integer, col_integer_alias, col_int_alias, col_serial, col_bigint, col_bigint_alias, col_decimal, col_decimal_alias, col_real, col_real_alias, col_double_precision, col_double_precision_alias, col_money
FROM NumericTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetNumericsRow {
    pub col_smallint: Option<i16>,
    pub col_smallint_alias: Option<i16>,
    pub col_integer: Option<i32>,
    pub col_integer_alias: Option<i32>,
    pub col_int_alias: Option<i32>,
    pub col_serial: Option<i32>,
    pub col_bigint: Option<i64>,
    pub col_bigint_alias: Option<i64>,
    pub col_decimal: Option<rust_decimal::Decimal>,
    pub col_decimal_alias: Option<rust_decimal::Decimal>,
    pub col_real: Option<f32>,
    pub col_real_alias: Option<f32>,
    pub col_double_precision: Option<f64>,
    pub col_double_precision_alias: Option<f64>,
    pub col_money: Option<postgres_money::Money>,
}
pub async fn get_numerics(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetNumericsRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_NUMERICS, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetNumericsRow {
            col_smallint: r.try_get(0)?,
            col_smallint_alias: r.try_get(1)?,
            col_integer: r.try_get(2)?,
            col_integer_alias: r.try_get(3)?,
            col_int_alias: r.try_get(4)?,
            col_serial: r.try_get(5)?,
            col_bigint: r.try_get(6)?,
            col_bigint_alias: r.try_get(7)?,
            col_decimal: r.try_get(8)?,
            col_decimal_alias: r.try_get(9)?,
            col_real: r.try_get(10)?,
            col_real_alias: r.try_get(11)?,
            col_double_precision: r.try_get(12)?,
            col_double_precision_alias: r.try_get(13)?,
            col_money: r.try_get(14)?,
        })
    }))
}
pub const GET_CHARACTERS: &str = r#"-- name: GetCharacters :many
SELECT col_char, col_char_alias, col_varchar, col_varchar_alias, col_text
FROM CharacterTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetCharactersRow {
    pub col_char: Option<String>,
    pub col_char_alias: Option<String>,
    pub col_varchar: Option<String>,
    pub col_varchar_alias: Option<String>,
    pub col_text: Option<String>,
}
pub async fn get_characters(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetCharactersRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_CHARACTERS, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetCharactersRow {
            col_char: r.try_get(0)?,
            col_char_alias: r.try_get(1)?,
            col_varchar: r.try_get(2)?,
            col_varchar_alias: r.try_get(3)?,
            col_text: r.try_get(4)?,
        })
    }))
}
pub const GET_BINARIES: &str = r#"-- name: GetBinaries :many
SELECT col_bytea
FROM BinaryTable"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetBinariesRow {
    pub col_bytea: Option<Vec<u8>>,
}
pub async fn get_binaries(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetBinariesRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_BINARIES, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetBinariesRow {
            col_bytea: r.try_get(0)?,
        })
    }))
}
pub const GET_CUSTOM_TYPE: &str = r#"-- name: GetCustomType :many
SELECT voice_actor, character
FROM SpongeBobVoiceActor"#;
#[derive(PartialEq, Debug, Clone)]
pub struct GetCustomTypeRow {
    pub voice_actor: Option<crate::VoiceActor>,
    pub character: Option<SpongeBobCharacter>,
}
pub async fn get_custom_type(
    client: &impl tokio_postgres::GenericClient,
) -> Result<
    impl Iterator<Item = Result<GetCustomTypeRow, tokio_postgres::Error>>,
    tokio_postgres::Error,
> {
    let rows = client.query(GET_CUSTOM_TYPE, &[]).await?;
    Ok(rows.into_iter().map(|r| {
        Ok(GetCustomTypeRow {
            voice_actor: r.try_get(0)?,
            character: r.try_get(1)?,
        })
    }))
}
pub const CREATE_VOICE_ACTOR: &str = r#"-- name: CreateVoiceActor :one
INSERT INTO SpongeBobVoiceActor
(voice_actor,character)
VALUES ($1, $2)
RETURNING voice_actor, character"#;
#[derive(PartialEq, Debug, Clone)]
pub struct CreateVoiceActorRow {
    pub voice_actor: Option<crate::VoiceActor>,
    pub character: Option<SpongeBobCharacter>,
}
pub async fn create_voice_actor(
    client: &impl tokio_postgres::GenericClient,
    voice_actor: Option<&crate::VoiceActor>,
    character: Option<&SpongeBobCharacter>,
) -> Result<Option<CreateVoiceActorRow>, tokio_postgres::Error> {
    let row = client
        .query_opt(CREATE_VOICE_ACTOR, &[&voice_actor, &character])
        .await?;
    let v = match row {
        Some(v) => CreateVoiceActorRow {
            voice_actor: v.try_get(0)?,
            character: v.try_get(1)?,
        },
        None => return Ok(None),
    };
    Ok(Some(v))
}
